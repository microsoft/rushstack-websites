---
hide_title: true
custom_edit_url: null
pagination_prev: null
pagination_next: null
---
<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [@rushstack/lookup-by-path](./lookup-by-path.md) &gt; [LookupByPath](./lookup-by-path.lookupbypath.md)

## LookupByPath class

> This API is provided as a beta preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.
> 

This class is used to associate path-like-strings, such as those returned by `git` commands, with entities that correspond with ancestor folders, such as Rush Projects or npm packages.

It is optimized for efficiently locating the nearest ancestor path with an associated value.

It is implemented as a Trie (https://en.wikipedia.org/wiki/Trie) data structure, with each edge being a path segment.

**Signature:**

```typescript
export declare class LookupByPath<TItem extends {}> implements IReadonlyLookupByPath<TItem> 
```
**Implements:** [IReadonlyLookupByPath](./lookup-by-path.ireadonlylookupbypath.md)<></>&lt;TItem&gt;

## Example


```ts
const trie = new LookupByPath([['foo', 1], ['bar', 2], ['foo/bar', 3]]);
trie.findChildPath('foo'); // returns 1
trie.findChildPath('foo/baz'); // returns 1
trie.findChildPath('baz'); // returns undefined
trie.findChildPath('foo/bar/baz'); returns 3
trie.findChildPath('bar/foo/bar'); returns 2
```

## Constructors

<table><thead><tr><th>

Constructor


</th><th>

Modifiers


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[(constructor)(entries, delimiter)](./lookup-by-path.lookupbypath._constructor_.md)


</td><td>


</td><td>

**_(BETA)_** Constructs a new `LookupByPath`


</td></tr>
</tbody></table>

## Properties

<table><thead><tr><th>

Property


</th><th>

Modifiers


</th><th>

Type


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[delimiter](./lookup-by-path.lookupbypath.delimiter.md)


</td><td>

`readonly`


</td><td>

string


</td><td>

**_(BETA)_** The delimiter used to split paths


</td></tr>
<tr><td>

[size](./lookup-by-path.lookupbypath.size.md)


</td><td>

`readonly`


</td><td>

number


</td><td>

**_(BETA)_** Gets the number of entries in this trie.


</td></tr>
<tr><td>

[tree](./lookup-by-path.lookupbypath.tree.md)


</td><td>

`readonly`


</td><td>

[IReadonlyPathTrieNode](./lookup-by-path.ireadonlypathtrienode.md)<></>&lt;TItem&gt;


</td><td>

**_(BETA)_**


</td></tr>
</tbody></table>

## Methods

<table><thead><tr><th>

Method


</th><th>

Modifiers


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[\[Symbol.iterator\](query, delimiter)](./lookup-by-path.lookupbypath._symbol.iterator_.md)


</td><td>


</td><td>

**_(BETA)_** The readonly component of `LookupByPath`<></>, to simplify unit testing.


</td></tr>
<tr><td>

[clear()](./lookup-by-path.lookupbypath.clear.md)


</td><td>


</td><td>

**_(BETA)_** Deletes all entries from this `LookupByPath` instance.


</td></tr>
<tr><td>

[deleteItem(query, delimeter)](./lookup-by-path.lookupbypath.deleteitem.md)


</td><td>


</td><td>

**_(BETA)_** Deletes an item if it exists.


</td></tr>
<tr><td>

[deleteSubtree(query, delimeter)](./lookup-by-path.lookupbypath.deletesubtree.md)


</td><td>


</td><td>

**_(BETA)_** Deletes an item and all its children.


</td></tr>
<tr><td>

[entries(query, delimiter)](./lookup-by-path.lookupbypath.entries.md)


</td><td>


</td><td>

**_(BETA)_** The readonly component of `LookupByPath`<></>, to simplify unit testing.


</td></tr>
<tr><td>

[findChildPath(childPath, delimiter)](./lookup-by-path.lookupbypath.findchildpath.md)


</td><td>


</td><td>

**_(BETA)_** The readonly component of `LookupByPath`<></>, to simplify unit testing.


</td></tr>
<tr><td>

[findChildPathFromSegments(childPathSegments)](./lookup-by-path.lookupbypath.findchildpathfromsegments.md)


</td><td>


</td><td>

**_(BETA)_** The readonly component of `LookupByPath`<></>, to simplify unit testing.


</td></tr>
<tr><td>

[findLongestPrefixMatch(query, delimiter)](./lookup-by-path.lookupbypath.findlongestprefixmatch.md)


</td><td>


</td><td>

**_(BETA)_** The readonly component of `LookupByPath`<></>, to simplify unit testing.


</td></tr>
<tr><td>

[get(key, delimiter)](./lookup-by-path.lookupbypath.get.md)


</td><td>


</td><td>

**_(BETA)_** The readonly component of `LookupByPath`<></>, to simplify unit testing.


</td></tr>
<tr><td>

[getNodeAtPrefix(query, delimiter)](./lookup-by-path.lookupbypath.getnodeatprefix.md)


</td><td>


</td><td>

**_(BETA)_** The readonly component of `LookupByPath`<></>, to simplify unit testing.


</td></tr>
<tr><td>

[groupByChild(infoByPath, delimiter)](./lookup-by-path.lookupbypath.groupbychild.md)


</td><td>


</td><td>

**_(BETA)_** The readonly component of `LookupByPath`<></>, to simplify unit testing.


</td></tr>
<tr><td>

[has(key, delimiter)](./lookup-by-path.lookupbypath.has.md)


</td><td>


</td><td>

**_(BETA)_** The readonly component of `LookupByPath`<></>, to simplify unit testing.


</td></tr>
<tr><td>

[iteratePathSegments(serializedPath, delimiter)](./lookup-by-path.lookupbypath.iteratepathsegments.md)


</td><td>

`static`


</td><td>

**_(BETA)_** Iterates over the segments of a serialized path.


</td></tr>
<tr><td>

[setItem(serializedPath, value, delimiter)](./lookup-by-path.lookupbypath.setitem.md)


</td><td>


</td><td>

**_(BETA)_** Associates the value with the specified serialized path. If a value is already associated, will overwrite.


</td></tr>
<tr><td>

[setItemFromSegments(pathSegments, value)](./lookup-by-path.lookupbypath.setitemfromsegments.md)


</td><td>


</td><td>

**_(BETA)_** Associates the value with the specified path. If a value is already associated, will overwrite.


</td></tr>
</tbody></table>

