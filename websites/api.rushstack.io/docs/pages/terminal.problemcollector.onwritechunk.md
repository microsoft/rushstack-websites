---
hide_title: true
custom_edit_url: null
pagination_prev: null
pagination_next: null
---
<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [@rushstack/terminal](./terminal.md) &gt; [ProblemCollector](./terminal.problemcollector.md) &gt; [onWriteChunk](./terminal.problemcollector.onwritechunk.md)

## ProblemCollector.onWriteChunk() method

> This API is provided as a beta preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.
> 

The abstract base class for objects that can present, route, or process text output for a console application. This output is typically prepared using the [Terminal](./terminal.terminal.md) API.

**Signature:**

```typescript
protected onWriteChunk(chunk: ITerminalChunk): void;
```

## Parameters

<table><thead><tr><th>

Parameter


</th><th>

Type


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

chunk


</td><td>

[ITerminalChunk](./terminal.iterminalchunk.md)


</td><td>


</td></tr>
</tbody></table>

**Returns:**

void

## Remarks

The design is based loosely on the `WritableStream` and `TransformStream` classes from the system [Streams API](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Concepts)<></>, except that instead of asynchronous byte streams, the `TerminalWritable` system synchronously transmits human readable messages intended to be rendered on a text console or log file.

Consider a console application whose output may need to be processed in different ways before finally being output. The conceptual block diagram might look like this:

```
         [Terminal API]
                |
                V
       [normalize newlines]
                |
                V
      +----[splitter]-------+
      |                     |
      V                     V
  [shell console]     [remove ANSI colors]
                            |
                            V
                      [write to build.log]
```
The application uses the `Terminal` API to print `stdout` and `stderr` messages, for example with standardized formatting for errors and warnings, and ANSI escapes to make nice colors. Maybe it also includes text received from external processes, whose newlines may be inconsistent. Ultimately we want to write the output to the shell console and a `build.log` file, but we don't want to put ANSI colors in the build log.

For the above example, `[shell console]` and `[write to build.log]` would be modeled as subclasses of `TerminalWritable`<></>. The `[normalize newlines]` and `[remove ANSI colors]` steps are modeled as subclasses of [TerminalTransform](./terminal.terminaltransform.md)<></>, because they output to a "destination" object. The `[splitter]` would be implemented using [SplitterTransform](./terminal.splittertransform.md)<></>.

The stream of messages are [ITerminalChunk](./terminal.iterminalchunk.md) objects, which can represent both `stdout` and `stderr` channels. The pipeline operates synchronously on each chunk, but by processing one chunk at a time, it avoids storing the entire output in memory. This means that operations like `[remove ANSI colors]` cannot be simple regular expressions -- they must be implemented as state machines ([TextRewriter](./terminal.textrewriter.md) subclasses) capable of matching substrings that span multiple chunks.

